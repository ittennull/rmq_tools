@page "/{queueName}"
@using System.Text.Json
@using RmqToolsWeb.Dtos
@inject HttpClient Http

<SectionContent SectionName="top-bar">
    <MudStack Spacing="5" Row="true">
        <div>
            <div><b>@QueueName</b></div>
            <div>
                <MudText Inline="true" Color="Color.Info">@_numberOfRemoteMessages</MudText> @MessageWord(_numberOfRemoteMessages) in RMQ
                 • 
                <MudText Inline="true" Color="Color.Info">@(_messages.Count)</MudText> @MessageWord(_messages.Count) in DB
            </div>
        </div>

        <div>
            <MudButton Variant="Variant.Outlined" Color="Color.Info" OnClick="LoadMessages">Load messages</MudButton>
        </div>
    </MudStack>
    
    <MudSpacer />
    
    <MudStack Spacing="1" Row="true">
        @if (_selectedMessages.Count > 0)
        {
            <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Inherit" OnClick="UnselectAll" title="Unselect all"/>
            <MudText Class="align-content-center" Color="Color.Info">@($"{_selectedMessages.Count} selected")</MudText>
        }
    </MudStack>
    
    <MudStack Spacing="1" Row="true" Class="ml-5">
        <MudSelect @bind-Value="_moveToQueue" Variant="Variant.Outlined" Label="Send to queue" Margin="Margin.Dense" Dense="true" FitContent="true">
            @foreach (var queueName in _queueNames)
            {
                <MudSelectItem Value="queueName">
                    @($"{queueName}" + (queueName == QueueName ? " ★" : ""))
                </MudSelectItem>
            }
        </MudSelect>
        
        @{
            var howMany = _selectedMessages.Count > 0 ? $"{_selectedMessages.Count}" : "all";
            var messages = MessageWord(_selectedMessages.Count);
        }
        <MudIconButton Icon="@Icons.Material.Filled.Send" Color="Color.Warning" OnClick="SendMessagesToQueue" title="@($"Send {howMany} {messages} to specified queue")" Disabled="@(!CanSendOrDeleteMessages)"/>
        <MudIconButton Icon="@Icons.Material.Filled.DeleteSweep" Color="Color.Error" OnClick="DeleteMessages" title="@($"Delete {howMany} {messages}")" Disabled="@(!CanSendOrDeleteMessages)"/>
    </MudStack>
</SectionContent>

<PageTitle>@QueueName</PageTitle>

<MudDataGrid Items="@_messages" Dense="true" Hover="true" Loading="@_loading" Hideable="true" ShowMenuIcon="true"
             ColumnsPanelReordering="true"
             MultiSelection="true" @bind-SelectedItems="_selectedMessages" SelectOnRowClick="false"
             Filterable="true" FilterMode="DataGridFilterMode.ColumnFilterRow" FilterCaseSensitivity="DataGridFilterCaseSensitivity.CaseInsensitive">
    <Columns>
        <SelectColumn T="Message" Hideable="false" />
        <PropertyColumn Property="x => x.Payload" Title="Headers">
            <CellTemplate>
                <pre>@context.Item.Payload</pre>
            </CellTemplate>
        </PropertyColumn>
        <PropertyColumn Property="x => x.Payload" Title="Payload">
            <CellTemplate>
                <pre>@context.Item.Payload</pre>
            </CellTemplate>
        </PropertyColumn>
    </Columns>
    <PagerContent>
        <MudDataGridPager T="Message" PageSizeOptions="@([100, 1000, 10000])" />
    </PagerContent>
</MudDataGrid>

@code {
    [Parameter]
    public required string QueueName { get; set; }

    List<Message> _messages = [];
    bool _loading;
    HashSet<Message> _selectedMessages = [];
    string _moveToQueue = "";
    string[] _queueNames = [];
    int _numberOfRemoteMessages;
    uint? _queueId;

    public bool CanSendOrDeleteMessages => _queueId != null && _messages.Count != 0;
    
    protected override async Task OnInitializedAsync()
    {
        _moveToQueue = QueueName;

        var queues = (await Http.GetFromJsonAsync<List<QueueSummary>>("/api/queues", MySourceGenerationContext.Default.ListQueueSummary))!;
        _queueNames = queues
            .Where(x => !x.Exclusive)
            .Select(x => x.Name)
            .Order()
            .ToArray();

        if (queues.SingleOrDefault(x => x.Name == QueueName) is { } requestedQueue)
        {
            _numberOfRemoteMessages = requestedQueue.MessageCountInRmq;

            if (requestedQueue.QueueId != null)
            {
                _queueId = requestedQueue.QueueId;
                _messages = (await Http.GetFromJsonAsync<List<Message>>($"/api/queues/{_queueId}/messages", MySourceGenerationContext.Default.ListMessage))!;
            }
        }
    }

    async Task LoadMessages()
    {
        _loading = true;
        try
        {
            using var response = await Http.PostAsync($"/api/queue/load?queue_name={QueueName}", null);
            var content = (await response.Content.ReadFromJsonAsync<LoadMessagesByQueueNameResponse>(MySourceGenerationContext.Default.LoadMessagesByQueueNameResponse))!;
            _queueId = content.QueueId;
            _messages = content.Messages;
            _numberOfRemoteMessages = 0;
        }
        finally
        {
            _loading = false;
        }
    }

    void UnselectAll()
    {
        _selectedMessages.Clear();
    }

    async Task DeleteMessages()
    {
        ShowLoadingForOperationOnMessages();
        
        var body = new DeleteMessagesRequest(_selectedMessages.Select(x => x.Id));
        using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"/api/queues/{_queueId}/messages");
        httpRequestMessage.Content = new ByteArrayContent(JsonSerializer.SerializeToUtf8Bytes(body, MySourceGenerationContext.Default.DeleteMessagesRequest));
        httpRequestMessage.Content.Headers.ContentType = new("application/json");
        using var response = await Http.SendAsync(httpRequestMessage);
        response.EnsureSuccessStatusCode();

        ClearMessagesAfterOperation();
        
        _loading = false;
    }
    
    async Task SendMessagesToQueue()
    {
        ShowLoadingForOperationOnMessages();
        
        var body = new SendMessagesRequest(_moveToQueue, _selectedMessages.Select(x => x.Id));
        using var response = await Http.PostAsJsonAsync($"/api/queues/{_queueId}/messages/send", body, MySourceGenerationContext.Default.SendMessagesRequest);
        response.EnsureSuccessStatusCode();

        if (_moveToQueue == QueueName)
            _numberOfRemoteMessages += _selectedMessages.Count == 0 ? _messages.Count : _selectedMessages.Count;
        
        ClearMessagesAfterOperation();
        
        _loading = false;
    }

    void ClearMessagesAfterOperation()
    {
        if (_selectedMessages.Count == 0)
            _messages.Clear();
        else
            _messages.RemoveAll(x => _selectedMessages.Contains(x));
        _selectedMessages.Clear();
    }
    
    string MessageWord(int count) => count == 1 ? "message" : "messages";

    void ShowLoadingForOperationOnMessages()
    {
        const int threshold = 100;
        if (_selectedMessages.Count > threshold || (_selectedMessages.Count == 0 && _messages.Count > threshold))
            _loading = true;
    }
}