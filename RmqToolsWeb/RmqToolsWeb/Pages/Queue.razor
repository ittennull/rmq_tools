@page "/{queueName}"
@using System.Text
@using System.Text.Json
@using MySourceGenerationContext = RmqToolsWeb.MySourceGenerationContext
@inject HttpClient Http

<SectionContent SectionName="top-bar">
    <MudStack Spacing="5" Row="true">
        <div>
            <div><b>@QueueName</b></div>
            <div>
                <MudText Inline="true" Color="Color.Info">@_numberOfRemoteMessages</MudText> @MessageWord(_numberOfRemoteMessages) in RMQ
                 • 
                <MudText Inline="true" Color="Color.Info">@(_messages.Count)</MudText> @MessageWord(_messages.Count) in DB
            </div>
        </div>

        <div>
            <MudButton Variant="Variant.Outlined" Color="Color.Info" OnClick="LoadMessages">Load messages</MudButton>
        </div>
    </MudStack>
    
    <MudSpacer />
    
    <MudStack Spacing="1" Row="true">
        @if (_selectedMessages.Count > 0)
        {
            <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Inherit" OnClick="UnselectAll" title="Unselect all"/>
            <MudText Class="align-content-center" Color="Color.Info">@($"{_selectedMessages.Count} selected")</MudText>
        }
            
        <MudSelect @bind-Value="_moveToQueue" Variant="Variant.Outlined" Label="Send to queue" Margin="Margin.Dense" Dense="true" FullWidth="true" FitContent="false">
            @foreach (var queueName in _queueNames)
            {
                <MudSelectItem Value="queueName">
                    @($"{queueName}" + (queueName == QueueName ? " ★" : ""))
                </MudSelectItem>
            }
        </MudSelect>

        @{
            var howMany = _selectedMessages.Count > 0 ? $"{_selectedMessages.Count}" : "all";
            var messages = MessageWord(_selectedMessages.Count);
        }
        <MudIconButton Icon="@Icons.Material.Filled.Send" Color="Color.Warning" OnClick="SendMessagesToQueue" title="@($"Send {howMany} {messages} to specified queue")" Disabled="@(!CanSendOrDeleteMessages)"/>
        <MudIconButton Icon="@Icons.Material.Filled.DeleteSweep" Color="Color.Error" OnClick="DeleteMessages" title="@($"Delete {howMany} {messages}")" Disabled="@(!CanSendOrDeleteMessages)"/>
    </MudStack>
</SectionContent>

<PageTitle>@QueueName</PageTitle>

<MudStack Row="true" Spacing="0" Class="ma-2">
    <MudText Class="d-flex align-center">Show message</MudText>
    <MudRadioGroup @bind-Value="_showMessageParts">
        <MudRadio Value="@ShowMessageParts.Headers">headers</MudRadio>
        <MudRadio Value="@ShowMessageParts.Payload">payload</MudRadio>
        <MudRadio Value="@ShowMessageParts.Both">both</MudRadio>
    </MudRadioGroup>
    
    <MudSpacer/>
    
    <MudTextField Value="_lineFilter" Label="Line filter" Variant="Variant.Text" ValueChanged="@((string s) => SetLineFilter(s))" Clearable="true"  />
    
</MudStack>

<MudDataGrid Items="@_messages" Dense="true" Hover="true" Loading="@_loading" Hideable="true"
             ColumnsPanelReordering="true" Elevation="5" Class="overflow-auto"
             MultiSelection="true" @bind-SelectedItems="_selectedMessages" SelectOnRowClick="false"
             Filterable="true" FilterMode="DataGridFilterMode.ColumnFilterRow" FilterCaseSensitivity="DataGridFilterCaseSensitivity.CaseInsensitive">
    <Columns>
        <SelectColumn T="MessageItem" Hideable="false" />
        <PropertyColumn Property="x => x.Index" Title="#" Sortable="true" Filterable="false" CellStyle="user-select: none;" />
        <PropertyColumn Property="x => x.CombinedString" Title="Message">
            <CellTemplate>
                @if (_showMessageParts is ShowMessageParts.Headers or ShowMessageParts.Both)
                {
                    @foreach (var kvp in context.Item.Message.Headers)
                    {
                        if (kvp.Value.ValueKind == JsonValueKind.Object)
                        {
                            <MudHighlighter Text="@GetFilteredLines($"{kvp.Key}: ").FirstOrDefault()" HighlightedText="@_lineFilter" CaseSensitive="false" />
                            <div class="ml-5">
                                @foreach (var prop in kvp.Value.EnumerateObject())
                                {
                                    foreach (var line in GetFilteredLines($"{prop.Name}: {prop.Value.ToString()}"))
                                    {
                                        <div style="white-space: pre-wrap;">
                                            <MudHighlighter Text="@line" HighlightedText="@_lineFilter" CaseSensitive="false" />
                                        </div>
                                    }
                                }
                            </div>
                        }
                        else
                        {
                            <div>
                                <MudHighlighter Text="@GetFilteredLines($"{kvp.Key}: {kvp.Value}").FirstOrDefault()" HighlightedText="@_lineFilter" CaseSensitive="false" />
                            </div>
                        }
                    }
                    
                    @if (_showMessageParts is ShowMessageParts.Both)
                    {
                        <br/>
                    }
                }
                
                @if (_showMessageParts is ShowMessageParts.Payload or ShowMessageParts.Both)
                {
                    <MudText Color="Color.Info">
                        <pre>
                            @foreach (var line in GetFilteredLines(context.Item.Message.Payload))
                            {
                                <MudHighlighter Text="@line" HighlightedText="@_lineFilter" CaseSensitive="false" />
                            }
                        </pre>
                    </MudText>
                }
            </CellTemplate>
        </PropertyColumn>
    </Columns>
    <PagerContent>
        <MudDataGridPager T="MessageItem" PageSizeOptions="@([100, 1000, 10000])" />
    </PagerContent>
</MudDataGrid>

@code {
    enum ShowMessageParts { Both, Headers, Payload }
    
    record MessageItem(int Index, Message Message, string CombinedString);
    
    [Parameter]
    public required string QueueName { get; set; }

    bool _loading;
    List<MessageItem> _messages = [];
    HashSet<MessageItem> _selectedMessages = [];
    string _moveToQueue = "";
    string[] _queueNames = [];
    int _numberOfRemoteMessages;
    uint? _queueId;
    ShowMessageParts _showMessageParts = ShowMessageParts.Both;
    string _lineFilter = "";

    bool CanSendOrDeleteMessages => _queueId != null && _messages.Count != 0;
    
    protected override async Task OnInitializedAsync()
    {
        _moveToQueue = QueueName;

        var queues = (await Http.GetFromJsonAsync<List<QueueSummary>>("/api/queues", MySourceGenerationContext.Default.ListQueueSummary))!;
        _queueNames = queues
            .Where(x => !x.Exclusive)
            .Select(x => x.Name)
            .Order()
            .ToArray();

        if (queues.SingleOrDefault(x => x.Name == QueueName) is { } requestedQueue)
        {
            _numberOfRemoteMessages = requestedQueue.MessageCountInRmq;

            if (requestedQueue.QueueId != null)
            {
                _queueId = requestedQueue.QueueId;
                var messages = (await Http.GetFromJsonAsync<List<Message>>($"/api/queues/{_queueId}/messages", MySourceGenerationContext.Default.ListMessage))!;
                CreateMessageItems(messages);
            }
        }
    }

    async Task LoadMessages()
    {
        _loading = true;
        try
        {
            using var response = await Http.PostAsync($"/api/queue/load?queue_name={QueueName}", null);
            var content = (await response.Content.ReadFromJsonAsync<LoadMessagesByQueueNameResponse>(MySourceGenerationContext.Default.LoadMessagesByQueueNameResponse))!;
            _queueId = content.QueueId;
            CreateMessageItems(content.Messages);
            _numberOfRemoteMessages = 0;
        }
        finally
        {
            _loading = false;
        }
    }

    void UnselectAll()
    {
        _selectedMessages.Clear();
    }

    async Task DeleteMessages()
    {
        ShowLoadingForOperationOnMessages();
        
        var body = new DeleteMessagesRequest(_selectedMessages.Select(x => x.Message.Id));
        using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"/api/queues/{_queueId}/messages");
        httpRequestMessage.Content = new ByteArrayContent(JsonSerializer.SerializeToUtf8Bytes(body, MySourceGenerationContext.Default.DeleteMessagesRequest));
        httpRequestMessage.Content.Headers.ContentType = new("application/json");
        using var response = await Http.SendAsync(httpRequestMessage);
        response.EnsureSuccessStatusCode();

        ClearMessagesAfterOperation();
        
        _loading = false;
    }
    
    async Task SendMessagesToQueue()
    {
        ShowLoadingForOperationOnMessages();
        
        var body = new SendMessagesRequest(_moveToQueue, _selectedMessages.Select(x => x.Message.Id));
        using var response = await Http.PostAsJsonAsync($"/api/queues/{_queueId}/messages/send", body, MySourceGenerationContext.Default.SendMessagesRequest);
        response.EnsureSuccessStatusCode();

        if (_moveToQueue == QueueName)
            _numberOfRemoteMessages += _selectedMessages.Count == 0 ? _messages.Count : _selectedMessages.Count;
        
        ClearMessagesAfterOperation();
        
        _loading = false;
    }

    void ClearMessagesAfterOperation()
    {
        if (_selectedMessages.Count == 0)
            _messages.Clear();
        else
            _messages.RemoveAll(x => _selectedMessages.Contains(x));
        _selectedMessages.Clear();
    }
    
    string MessageWord(int count) => count == 1 ? "message" : "messages";

    void ShowLoadingForOperationOnMessages()
    {
        const int threshold = 100;
        if (_selectedMessages.Count > threshold || (_selectedMessages.Count == 0 && _messages.Count > threshold))
            _loading = true;
    }

    void CreateMessageItems(IEnumerable<Message> messages)
    {
        _messages.Clear();
        _messages.AddRange(messages
            .Index()
            .Select(x => new MessageItem(x.Index + 1, x.Item, GetCombinedString(x.Item)))
            .OrderBy(x => x.Index));
    }

    string GetCombinedString(Message message)
    {
        var sb = new StringBuilder();
        
        foreach (var kvp in message.Headers)
        {
            sb.Append(kvp.Key);
            if (kvp.Value.ValueKind == JsonValueKind.Object)
            {
                foreach (var prop in kvp.Value.EnumerateObject())
                {
                    sb.Append(prop.Name);
                    sb.Append(prop.Value);
                }
            }
            else
            {
                sb.Append(kvp.Value);
            }
        }

        sb.Append(message.Payload);

        return sb.ToString();
    }

    void SetLineFilter(string s)
    {
        _lineFilter = s;
    }

    IEnumerable<string> GetFilteredLines(string line)
    {
        if (_lineFilter == string.Empty)
        {
            yield return line;
            yield break;
        }

        int index = 0;
        while (true)
        {
            var (wholeLine, endIndex) = FindString(line, index);
            if (wholeLine != null)
                yield return wholeLine;
            
            if (wholeLine == null || endIndex == line.Length)
                yield break;
            
            index = endIndex;
        }
    }

    (string? wholeLine, int endIndex) FindString(string line, int lineStartIndex)
    {
        if (line.Length == 0)
            return default;
        
        var index = line.IndexOf(_lineFilter, lineStartIndex, StringComparison.InvariantCultureIgnoreCase);
        if (index == -1)
            return default;
        
        // find a start of the string
        var startIndex = line.LastIndexOf('\n', index);
        startIndex += 1;
        
        // find an end of the string
        var endIndex = line.IndexOf('\n', index + _lineFilter.Length);
        endIndex = endIndex == -1 ? line.Length : endIndex + 1;

        return (line[startIndex .. endIndex], endIndex);
    }
}
