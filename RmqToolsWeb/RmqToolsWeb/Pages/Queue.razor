@page "/{queueName}"

<SectionContent SectionName="top-bar">
    <MudStack Spacing="5" Row="true">
        <div>
            <div><b>@QueueName</b></div>
            <div>
                <MudText Inline="true" Color="@(_numberOfRemoteMessagesIsOutOfDate ? Color.Warning : Color.Info)">@_numberOfRemoteMessages</MudText> @MessageWord(_numberOfRemoteMessages) in RMQ
                 • 
                <MudText Inline="true" Color="Color.Info">@(_numberOfMessagesInDb)</MudText> @MessageWord(_numberOfMessagesInDb) in DB
            </div>
        </div>

        <MudButton Variant="Variant.Outlined" Color="Color.Info" OnClick="LoadMessages">Load messages</MudButton>
    </MudStack>
    
    <MudSpacer />
    
    @if (_readonlyMode is true)
    {
        <MudText Color="Color.Secondary" Typo="Typo.body2">Peek mode. <br/>Load messages to be able to change anything</MudText>
    }
    else if(_readonlyMode is false)
    {
        <MudStack Spacing="1" Row="true">
            @if (_selectedMessages.Count > 0)
            {
                <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Inherit" OnClick="UnselectAll" title="Unselect all"/>
                <MudText Class="align-content-center" Style="white-space: nowrap;" Color="Color.Info">@($"{_selectedMessages.Count} selected")</MudText>
            }
                
            <MudSelect @bind-Value="_moveToQueue" Variant="Variant.Outlined" Class="ml-1" Label="Send to queue" Margin="Margin.Dense" Dense="true" FullWidth="true" FitContent="true">
                @foreach (var queueName in _queueNames)
                {
                    <MudSelectItem Value="queueName">
                        @($"{queueName}" + (queueName == QueueName ? " ★" : ""))
                    </MudSelectItem>
                }
            </MudSelect>
            
            @{
                var howMany = _selectedMessages.Count > 0 ? $"{_selectedMessages.Count}" : "all";
                var messages = MessageWord(_selectedMessages.Count);
            }
            <MudIconButton Icon="@Icons.Material.Filled.Send" Color="Color.Warning" OnClick="SendMessagesToQueue" title="@($"Send {howMany} {messages} to specified queue")" Disabled="@(!CanSendOrDeleteMessages)"/>
            <MudIconButton Icon="@Icons.Material.Filled.DeleteSweep" Color="Color.Error" OnClick="DeleteMessages" title="@($"Delete {howMany} {messages}")" Disabled="@(!CanSendOrDeleteMessages)"/>
        </MudStack>
    }
</SectionContent>

<PageTitle>@QueueName</PageTitle>

<MudStack Row="true" Spacing="0" Class="pa-2" Style="background-color: var(--mud-palette-surface);">
    <MudText Class="d-flex align-center">Show message</MudText>
    <MudRadioGroup @bind-Value="_showMessageParts">
        <MudRadio Value="@ShowMessageParts.Headers">headers</MudRadio>
        <MudRadio Value="@ShowMessageParts.Payload">payload</MudRadio>
        <MudRadio Value="@ShowMessageParts.Both">both</MudRadio>
    </MudRadioGroup>
    
    <MudSpacer/>
    
    <MudTextField @bind-Value="_groupBySelector" Label="Group by line containing" Variant="Variant.Text" Clearable="true" Class="mr-5" />
    <MudTextField Value="_lineFilter" Label="Line filter" Variant="Variant.Text" ValueChanged="@((string s) => SetLineFilter(s))" Clearable="true"  />
    <MudIconButton Icon="@Icons.Material.Filled.LibraryBooks" Color="Color.Inherit" Size="Size.Medium" Edge="Edge.Start" OnClick="ExportFilteredLines"
                   Disabled="@(string.IsNullOrWhiteSpace(_lineFilter))" title="Export filtered lines" Class="ml-1" />
</MudStack>

<MudDataGrid @ref="_dataGrid" 
        Items="@_messages" Dense="true" Hover="true" Loading="@_loading" Hideable="true" RowStyle="vertical-align: top;"
        ColumnsPanelReordering="true" Elevation="5" Class="overflow-auto"
        MultiSelection="true" @bind-SelectedItems="_selectedMessages" SelectOnRowClick="false"
        Filterable="true" FilterMode="DataGridFilterMode.ColumnFilterRow" FilterCaseSensitivity="DataGridFilterCaseSensitivity.CaseInsensitive">
    <Columns>
        @if (_readonlyMode is false)
        {
            <SelectColumn T="MessageItem" Hideable="false"/>
        }

        <PropertyColumn Property="x => x.CombinedString" Title="Message" Groupable="@GroupingEnabled" GroupBy="@(x => GroupMessagesBy(x))" Grouping="@GroupingEnabled">
            <GroupTemplate>
                @if (_readonlyMode is false)
                {
                    <MudButton Color="Color.Default" Variant="Variant.Outlined" Class="mx-3" Size="Size.Small" OnClick="@(() => SelectAllInGroup(context.Grouping!))">Select</MudButton>
                }
                <b>@(context.Grouping.Count())</b> : @(context.Grouping.Key)
                @if (context.Grouping.Key == null)
                {
                    <i style="opacity: 80%">&nbsp; not matched by group filter</i>
                }
            </GroupTemplate>
            <CellTemplate>
                <details open>
                    <summary>
                        <div class="d-inline-block">
                            <div class="d-flex align-center">
                                @context.Item.Index
                                @if (_readonlyMode is false)
                                {
                                    <MudButton StartIcon="@Icons.Material.Filled.EditNote" Color="Color.Info" Size="Size.Small" Variant="Variant.Text" IconSize="Size.Large"
                                               OnClick="@(() => EditMessage(context.Item.Index))" title="Edit message payload" Class="mx-5 pa-0">
                                        Edit
                                    </MudButton>
                                }
                            </div>
                        </div>
                    </summary>

                    @{
                        var headersAreEmpty = true;
                    }
                    @if (_showMessageParts is ShowMessageParts.Headers or ShowMessageParts.Both)
                    {
                        var notEmptyLines = context.Item.HeaderLines
                            .Select(line => FilterLine(line, _lineFilter))
                            .Where(x => x != null);

                        <div style="white-space: pre-wrap;">
                            @foreach (var line in notEmptyLines)
                            {
                                headersAreEmpty = false;
                                <Highlighter Text="@line" Token="@_lineFilter"/>
                            }
                        </div>
                    }

                    @if (_showMessageParts is ShowMessageParts.Payload or ShowMessageParts.Both)
                    {
                        var notEmptyLines = context.Item.PayloadLines
                            .Select(line => FilterLine(line, _lineFilter))
                            .Where(x => x != null);
                        var separatorAdded = false;

                        <MudText Color="Color.Info">
                            <pre>
                                @foreach (var line in notEmptyLines)
                                {
                                    if (!separatorAdded && !headersAreEmpty)
                                    {
                                        separatorAdded = true;
                                        <br/>
                                    }

                                    <Highlighter Text="@line" Token="@_lineFilter"/>
                                }
                            </pre>
                        </MudText>
                    }
                </details>
            </CellTemplate>
        </PropertyColumn>
    </Columns>
    <PagerContent>
        <MudDataGridPager T="MessageItem" PageSizeOptions="@([100, 1000, 10000])" />
    </PagerContent>
</MudDataGrid>
